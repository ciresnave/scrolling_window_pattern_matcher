//! ScrollingWindowPatternMatcher
//!
//! A flexible, ergonomic pattern matcher for slices, arrays, and windows, supporting wildcards, custom logic, and builder patterns.
//!
//! # Features
//! - Wildcard matching (`PatternElem::Any`)
//! - Flexible matcher signatures: pass window and patterns as Vec, slice, or array, and patterns as owned or referenced
//! - Ergonomic builder patterns
//! - Custom matcher logic
//! - Flexible callback and overlap configuration

use std::{borrow::Borrow, fmt};

/// Pattern element: matches a value, a predicate, or any value (wildcard)
///
/// - `Value(T)`: Matches a specific value.
/// - `Matcher(Box<dyn Fn(&T) -> bool>)`: Matches using a custom predicate function.
/// - `Any`: Matches any value (wildcard).
///
/// Used to build flexible patterns for matching windows of data.
pub enum PatternElem<T> {
    /// Matches a specific value, with optional repeat and capture name.
    ///
    /// - `min_repeat`, `max_repeat`: Minimum and maximum number of times this element must repeat consecutively.
    /// - `capture_name`: If set, matched values are stored under this name in the output.
    Value {
        value: T,
        min_repeat: Option<usize>,
        max_repeat: Option<usize>,
        capture_name: Option<String>,
    },
    /// Matches using a custom predicate, with optional repeat and capture name
    Matcher {
        matcher: Box<dyn Fn(&T) -> bool + 'static>,
        min_repeat: Option<usize>,
        max_repeat: Option<usize>,
        capture_name: Option<String>,
    },
    /// Matches any value (wildcard), with optional repeat and capture name
    Any {
        min_repeat: Option<usize>,
        max_repeat: Option<usize>,
        capture_name: Option<String>,
    },
}

impl<T: fmt::Debug> fmt::Debug for PatternElem<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            PatternElem::Value { value, min_repeat, max_repeat, capture_name } => {
                write!(f, "Value({:?}, min_repeat={:?}, max_repeat={:?}, capture_name={:?})", value, min_repeat, max_repeat, capture_name)
            }
            PatternElem::Matcher { min_repeat, max_repeat, capture_name, .. } => {
                write!(f, "Matcher(.., min_repeat={:?}, max_repeat={:?}, capture_name={:?})", min_repeat, max_repeat, capture_name)
            }
            PatternElem::Any { min_repeat, max_repeat, capture_name } => {
                write!(f, "Any(min_repeat={:?}, max_repeat={:?}, capture_name={:?})", min_repeat, max_repeat, capture_name)
            }
        }
    }
}

/// Pattern: a sequence of pattern elements, with optional callback and overlap/deduplication settings
///
/// - `pattern`: Sequence of pattern elements.
/// - `callback`: Optional callback invoked on match.
/// - `overlap`: If false, prevents overlapping matches for this pattern.
/// - `deduplication`: If true, prevents duplicate matches for this pattern.
pub struct Pattern<T> {
    /// Sequence of pattern elements.
    pub pattern: Vec<PatternElem<T>>,
    /// Optional callback invoked on match.
    pub callback: Option<SliceCallback<T>>,
    /// If false, prevents overlapping matches for this pattern.
    pub overlap: bool,
    /// If true, prevents duplicate matches for this pattern.
    pub deduplication: bool,
    /// Optional name for this pattern (used in named output).
    pub name: Option<String>,
}

// Allow Pattern<T> to be used as AsRef<Pattern<T>>
impl<T> AsRef<Pattern<T>> for Pattern<T> {
    fn as_ref(&self) -> &Pattern<T> {
        self
    }
}

impl<T> Pattern<T> {
    /// Create a new pattern from a sequence of pattern elements
    pub fn new(pattern: Vec<PatternElem<T>>) -> Self {
        Self {
            pattern,
            callback: None,
            overlap: true,
            deduplication: false,
            name: None,
        }
    }
    /// Set the name for this pattern (used in named output)
    pub fn with_name(mut self, name: impl Into<String>) -> Self {
        self.name = Some(name.into());
        self
    }
    /// Set a callback to be invoked on match
    pub fn with_callback(mut self, cb: SliceCallback<T>) -> Self {
        self.callback = Some(cb);
        self
    }
    /// Set overlap behavior
    pub fn overlap(mut self, allow: bool) -> Self {
        self.overlap = allow;
        self
    }
    /// Set deduplication behavior
    pub fn deduplication(mut self, enable: bool) -> Self {
        self.deduplication = enable;
        self
    }
}

/// Builder for Pattern<T>
///
/// Use this builder to construct complex patterns with custom callbacks, overlap, and deduplication settings.
pub struct PatternBuilder<T> {
    /// Builder for constructing complex patterns with repeat, gap, and capture settings.
    // ...existing fields...
    pattern: Vec<PatternElem<T>>,
    callback: Option<SliceCallback<T>>,
    overlap: bool,
    deduplication: bool,
    name: Option<String>,
}

impl<T> PatternBuilder<T> {
    /// Add a value element to the pattern.
    ///
    /// Use builder methods like `min_repeat`, `max_repeat`, and `capture_name` to configure constraints for the last element.
    /// Add a matcher element to the pattern.
    ///
    /// Use builder methods like `min_repeat`, `max_repeat`, and `capture_name` to configure constraints for the last element.
    /// Add an any (wildcard) element to the pattern.
    ///
    /// Use builder methods like `min_repeat`, `max_repeat`, and `capture_name` to configure constraints for the last element.
    /// Set minimum repeat for the last element added to the pattern.
    /// Set maximum repeat for the last element added to the pattern.
    /// Set capture name for the last element added to the pattern.


    /// Set capture_name for the last element
    pub fn capture_name(mut self, name: impl Into<String>) -> Self {
        if let Some(last) = self.pattern.last_mut() {
            let name_str = Some(name.into());
            match last {
                PatternElem::Value { capture_name, .. } => *capture_name = name_str,
                PatternElem::Matcher { capture_name, .. } => *capture_name = name_str,
                PatternElem::Any { capture_name, .. } => *capture_name = name_str,
            }
        }
        self
    }
    /// Create a new builder
    pub fn new() -> Self {
        Self {
            pattern: Vec::new(),
            callback: None,
            overlap: true,
            deduplication: false,
            name: None,
        }
    }
    /// Set the name for this pattern
    pub fn name(mut self, name: impl Into<String>) -> Self {
        self.name = Some(name.into());
        self
    }
    /// Set the pattern elements
    pub fn pattern(mut self, elems: Vec<PatternElem<T>>) -> Self {
        self.pattern = elems;
        self
    }
    /// Set the callback
    pub fn callback<F>(mut self, cb: F) -> Self
    where
        F: Fn(&[T]) + 'static,
    {
        self.callback = Some(Box::new(cb));
        self
    }
    /// Set overlap behavior
    pub fn overlap(mut self, allow: bool) -> Self {
        self.overlap = allow;
        self
    }
    /// Set deduplication behavior
    pub fn deduplication(mut self, enable: bool) -> Self {
        self.deduplication = enable;
        self
    }
    /// Build the pattern
    pub fn build(self) -> Pattern<T> {
        Pattern {
            pattern: self.pattern,
            callback: self.callback,
            overlap: self.overlap,
            deduplication: self.deduplication,
            name: self.name,
        }
    }
}

/// Type alias for a callback on a slice
///
/// The callback receives a slice of matched window elements.
pub type SliceCallback<T> = Box<dyn Fn(&[T]) + 'static>;

/// The main matcher struct
///
/// Use this struct to perform pattern matching on windows of data. Supports flexible and ergonomic APIs.
#[derive(Debug, Clone)]
pub struct ScrollingWindowPatternMatcherRef {
    pub window_len: usize,
}

impl ScrollingWindowPatternMatcherRef {
    /// Find matches and return named captures in a HashMap output format.
    ///
    /// Output: `HashMap<pattern_name, Vec<HashMap<capture_name, Vec<T>>>>`
    ///
    /// Each pattern's name is used as the key, and each match produces a HashMap of capture names to matched values.
    /// Find matches and return named captures in a HashMap output format
    ///
    /// Output: HashMap<pattern_name, Vec<HashMap<capture_name, Vec<T>>>>
    pub fn find_named_matches<T>(&self, window: &[T], patterns: &[Pattern<T>]) -> std::collections::HashMap<String, Vec<std::collections::HashMap<String, Vec<T>>>>
    where
        T: PartialEq + Clone + std::fmt::Debug,
    {
        use std::collections::HashMap;
        let mut results: HashMap<String, Vec<HashMap<String, Vec<T>>>> = HashMap::new();
        for pat in patterns {
            let pat_name = pat.name.clone().unwrap_or_else(|| "unnamed".to_string());
            let pat_len = pat.pattern.len();
            if pat_len == 0 || window.is_empty() {
                continue;
            }
            let mut w_idx = 0;
            while w_idx < window.len() {
                let mut win_pos = w_idx;
                let mut captures: HashMap<String, Vec<T>> = HashMap::new();
                let mut matched = true;
                let mut match_indices = Vec::new();
                println!("\nPattern '{}' at window index {}", pat_name, w_idx);
                for (elem_idx, elem) in pat.pattern.iter().enumerate() {
                    // Handle repeats
                    let min_repeat = match elem {
                        PatternElem::Value { min_repeat, .. } => min_repeat,
                        PatternElem::Matcher { min_repeat, .. } => min_repeat,
                        PatternElem::Any { min_repeat, .. } => min_repeat,
                    };
                    let max_repeat = match elem {
                        PatternElem::Value { max_repeat, .. } => max_repeat,
                        PatternElem::Matcher { max_repeat, .. } => max_repeat,
                        PatternElem::Any { max_repeat, .. } => max_repeat,
                    };
                    let repeat_min = min_repeat.unwrap_or(1);
                    let repeat_max = max_repeat.unwrap_or(1);
                    println!("  Elem {}: repeat_min={}, repeat_max={}, win_pos={}", elem_idx, repeat_min, repeat_max, win_pos);
                    let mut repeat_count = 0;
                    let mut repeat_indices = Vec::new();
                    while repeat_count < repeat_max && win_pos < window.len() {
                        let elem_match = match elem {
                            PatternElem::Value { value, .. } => &window[win_pos] == value,
                            PatternElem::Matcher { matcher, .. } => matcher(&window[win_pos]),
                            PatternElem::Any { .. } => true,
                        };
                        println!("    Checking window[{}]={:?} elem_match={}", win_pos, &window[win_pos], elem_match);
                        if elem_match {
                            repeat_indices.push(win_pos);
                            repeat_count += 1;
                            win_pos += 1;
                        } else {
                            break;
                        }
                    }
                    println!("  Elem {}: repeat_count={}, repeat_indices={:?}", elem_idx, repeat_count, repeat_indices);
                    if repeat_count < repeat_min {
                        println!("  Elem {}: not enough repeats (got {}, need {})", elem_idx, repeat_count, repeat_min);
                        matched = false;
                        break;
                    }
                    match_indices.extend(repeat_indices.iter().copied());
                    // Handle capture
                    let capture_name = match elem {
                        PatternElem::Value { capture_name, .. } => capture_name,
                        PatternElem::Matcher { capture_name, .. } => capture_name,
                        PatternElem::Any { capture_name, .. } => capture_name,
                    };
                    if let Some(name) = capture_name {
                        let captured: Vec<T> = repeat_indices.iter().map(|&i| window[i].clone()).collect();
                        println!("  Elem {}: captured '{}' = {:?}", elem_idx, name, captured);
                        captures.insert(name.clone(), captured);
                    }
                }
                if matched && !match_indices.is_empty() {
                    println!("  Pattern '{}' matched at {}: captures={:?}", pat_name, w_idx, captures);
                    results.entry(pat_name.clone()).or_default().push(captures);
                } else {
                    println!("  Pattern '{}' did NOT match at {}", pat_name, w_idx);
                }
                w_idx += 1;
            }
        }
        results
    }
    /// Create a new matcher for a window of given length
    pub fn new(window_len: usize) -> Self {
        Self { window_len }
    }

    /// Flexible find_matches: accepts Vec, slice, or array for window and patterns
    /// Flexible pattern matching for windows and patterns.
    ///
    /// Accepts any owned or referenced container for the window (e.g., Vec, slice, array) and patterns (owned or referenced).
    ///
    /// Trait bounds:
    /// - `W: IntoIterator, W::Item: Borrow<T>`: Window can be owned or referenced; each item is borrowed for matching.
    /// - `T: Clone + PartialEq`: Window elements must be cloneable and comparable.
    /// - `P: IntoIterator, P::Item: AsRef<Pattern<T>>`: Patterns can be owned or referenced.
    ///
    /// Performance: Clones all window elements into a new Vec; may use more memory for large windows.
    ///
    /// Use this method for ergonomic API and flexibility. For maximum performance, use `find_matches` with slices.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use scrolling_window_pattern_matcher::{Pattern, PatternElem, ScrollingWindowPatternMatcherRef};
    /// let window = vec![1, 2, 1, 2, 1];
    /// let patterns = vec![
    ///     Pattern::new(vec![PatternElem::Value(1), PatternElem::Value(2)]),
    ///     Pattern::new(vec![PatternElem::Value(2), PatternElem::Value(1)]),
    /// ];
    /// let matcher = ScrollingWindowPatternMatcherRef::new(window.len());
    /// let matches = matcher.find_matches_flexible(window, &patterns);
    /// assert!(matches.contains(&(0, 0)));
    /// assert!(matches.contains(&(1, 1)));
    /// ```
    ///
    /// You can also pass patterns as references:
    ///
    /// ```rust
    /// use scrolling_window_pattern_matcher::{Pattern, PatternElem, ScrollingWindowPatternMatcherRef};
    /// let window = [1, 2, 1, 2, 1];
    /// let p1 = Pattern::new(vec![PatternElem::Value(1), PatternElem::Value(2)]);
    /// let p2 = Pattern::new(vec![PatternElem::Value(2), PatternElem::Value(1)]);
    /// let patterns = [&p1, &p2];
    /// let matcher = ScrollingWindowPatternMatcherRef::new(window.len());
    /// let matches = matcher.find_matches_flexible(window, &patterns);
    /// assert!(matches.contains(&(0, 0)));
    /// assert!(matches.contains(&(1, 1)));
    /// ```
    pub fn find_matches_flexible<T, W, P>(&self, window: W, patterns: P) -> Vec<(usize, usize)>
    where
        W: IntoIterator,
        W::Item: Borrow<T>,
        T: Clone + PartialEq,
        P: IntoIterator,
        P::Item: AsRef<Pattern<T>>,
        Pattern<T>: Clone,
    {
        let window_vec: Vec<T> = window.into_iter()
            .map(|x| x.borrow().clone())
            .collect();
        let patterns_vec: Vec<Pattern<T>> = patterns
            .into_iter()
            .map(|p| p.as_ref().clone())
            .collect();
        self.find_matches(&window_vec, &patterns_vec)
    }

    /// Find matches for a slice and a slice of patterns
    ///
    /// Returns a vector of (window index, pattern index) for all matches.
    ///
    /// Accepts slices for both window and patterns. No cloning is performed; matching is zero-copy and efficient.
    ///
    /// Trait bounds:
    /// - `T: PartialEq + Clone`: Window elements must be comparable and cloneable.
    ///
                for elem in &pat.pattern {
                    let min_repeat = match elem {
                        PatternElem::Value { min_repeat, .. } => min_repeat,
                        PatternElem::Matcher { min_repeat, .. } => min_repeat,
                        PatternElem::Any { min_repeat, .. } => min_repeat,
                    };
                    let max_repeat = match elem {
                        PatternElem::Value { max_repeat, .. } => max_repeat,
                        PatternElem::Matcher { max_repeat, .. } => max_repeat,
                        PatternElem::Any { max_repeat, .. } => max_repeat,
                    };
                    let repeat_min = min_repeat.unwrap_or(1);
                    let repeat_max = max_repeat.unwrap_or(1);
                    let mut repeat_count = 0;
                    let mut repeat_indices = Vec::new();
                    while repeat_count < repeat_max && win_pos < window.len() {
                        let elem_match = match elem {
                            PatternElem::Value { value, .. } => &window[win_pos] == value,
                            PatternElem::Matcher { matcher, .. } => matcher(&window[win_pos]),
                            PatternElem::Any { .. } => true,
                        };
                        if elem_match {
                            repeat_indices.push(win_pos);
                            repeat_count += 1;
                            win_pos += 1;
                        } else {
                            break;
                        }
                    }
                    if repeat_count < repeat_min {
                        matched = false;
                        break;
                    }
                    match_indices.extend(repeat_indices.iter().copied());
                    // Handle capture
                    let capture_name = match elem {
                        PatternElem::Value { capture_name, .. } => capture_name,
                        PatternElem::Matcher { capture_name, .. } => capture_name,
                        PatternElem::Any { capture_name, .. } => capture_name,
                    };
                    if let Some(name) = capture_name {
                        let captured: Vec<T> = repeat_indices.iter().map(|&i| window[i].clone()).collect();
                        captures.insert(name.clone(), captured);
                    }
                }
                if matched {
                    // Overlap checks per-pattern
                    let mut overlaps = false;
                    if !pat.overlap {
                        for &(start, end) in &matched_ranges {
                            let range_start = *match_indices.first().unwrap_or(&w_idx);
                            let range_end = *match_indices.last().unwrap_or(&w_idx);
                            if !(range_end < start || range_start > end) {
                                overlaps = true;
                                break;
                            }
                        }
                    }
                    if pat.overlap || !overlaps {
                        // Invoke callback if present
                        if let Some(ref cb) = pat.callback {
                            let matched_slice: Vec<T> = match_indices.iter().map(|&i| window[i].clone()).collect();
                            cb(&matched_slice);
                        }
                        matches.push((w_idx, p_idx));
                        if pat.deduplication {
                            let start = *match_indices.first().unwrap_or(&w_idx);
                            let end = *match_indices.last().unwrap_or(&w_idx);
                            matched_ranges.push((start, end));
                        }
                        // TODO: Store captures for new output format
                    }
                }
                w_idx += 1;
            }
        }
        matches
    }
}

// Re-export major types and builders for crate consumers

// Manual Clone for PatternElem, skipping Matcher
/// Manual implementation of Clone for PatternElem.
///
/// - `Value(v)`: Clones the value.
/// - `Any`: Returns Any.
/// - `Matcher`: Panics (cannot clone closures).
impl<T: Clone> Clone for PatternElem<T> {
    fn clone(&self) -> Self {
        match self {
            PatternElem::Value { value, min_repeat, max_repeat, capture_name } => PatternElem::Value {
                value: value.clone(),
                min_repeat: *min_repeat,
                max_repeat: *max_repeat,
                capture_name: capture_name.clone(),
            },
            PatternElem::Any { min_repeat, max_repeat, capture_name } => PatternElem::Any {
                min_repeat: *min_repeat,
                max_repeat: *max_repeat,
                capture_name: capture_name.clone(),
            },
            PatternElem::Matcher { .. } => panic!("Cannot clone PatternElem::Matcher"),
        }
    }
}

// Manual Clone for Pattern, skipping callback
/// Manual implementation of Clone for Pattern.
///
/// - Clones pattern elements, overlap, and deduplication settings.
/// - Callback is not cloned (set to None).
impl<T: Clone> Clone for Pattern<T> {
    fn clone(&self) -> Self {
        Pattern {
            pattern: self.pattern.clone(),
            callback: None, // Cannot clone callback
            overlap: self.overlap,
            deduplication: self.deduplication,
            name: self.name.clone(),
        }
    }
}
