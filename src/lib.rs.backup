//! # Scrolling Window Pattern Matcher
//!
//! This crate provides a generic pattern matcher that operates over a scrolling window (queue) of items.
//! Patterns can be defined as sequences of values, functions, or a mix of both. When a pattern matches,
//! an optional user-defined callback is invoked. The matcher supports optional deduplication of matches.
//!
//! ## Features
//! - Match patterns using values, functions, or both
//! - Optional deduplication of matches
//! - Support for overlapping matches
//! - Callback invocation on match
//! - No unnecessary trait bounds: PartialEq is only required for value-based patterns
//!
//! ## Usage
//!
//! ```rust
//! use scrolling_window_pattern_matcher::{ScrollingWindowPatternMatcherRef, PatternElem};
//! let window = vec![&1, &2, &3, &4];
//! let patterns = vec![
//!     PatternElem::Value(1),
//!     PatternElem::Matcher(Box::new(|x: &i32| *x == 2)),
//! ];
//! let matcher = ScrollingWindowPatternMatcherRef::new(4);
//! let matches = matcher.find_matches(&window, &patterns, false, None::<fn(usize, usize)>);
//! assert!(matches.contains(&(0, 0)));
//! assert!(matches.contains(&(1, 1)));
//! ```
//!
//! ## Function-only Patterns
//!
//! ```rust
//! use scrolling_window_pattern_matcher::ScrollingWindowFunctionPatternMatcherRef;
//! let window = vec![&1, &2, &3, &4];
//! let patterns_fn: Vec<Box<dyn Fn(&i32) -> bool>> = vec![
//!     Box::new(|x| *x == 1),
//!     Box::new(|x| *x == 4),
//! ];
//! let matcher = ScrollingWindowFunctionPatternMatcherRef::new(4);
//! let matches = matcher.find_matches(&window, &patterns_fn[..], false, None::<fn(usize, usize)>);
//! assert!(matches.contains(&(0, 0)));
//! assert!(matches.contains(&(1, 3)));
//! ```
//!
//! ## Deduplication and Overlapping Matches
//!
//! Set `deduplicate` to `true` to avoid reporting the same match more than once.
//!
//! ## Callback Example
//!
//! ```rust
//! use scrolling_window_pattern_matcher::{ScrollingWindowPatternMatcherRef, PatternElem};
//! let window = vec![&1, &2, &3];
//! let patterns = vec![PatternElem::Value(2)];
//! let matcher = ScrollingWindowPatternMatcherRef::new(3);
//! let mut called = false;
//! let _ = matcher.find_matches(&window, &patterns, false, Some(|pid, idx| {
//!     assert_eq!(pid, 0);
//!     assert_eq!(idx, 1);
//!     called = true;
//! }));
//! assert!(called);
//! ```
//!
//! ## Edge Cases
//!
//! - Empty window or patterns: returns no matches
//! - Patterns can be all values, all functions, or mixed
//!
//! ## API
//!
//! - `find_matches`: Use for value or mixed patterns (requires PartialEq for T)
//! - `find_matches_functions_only`: Use for function-only patterns (no trait bound required)
//!
//! See tests for more examples.

use std::collections::{VecDeque, HashMap};

/// A single element in a pattern: either an exact value or a matcher function.
pub enum PatternElem<T> {
    Value(T),
    Matcher(Box<dyn Fn(&T) -> bool>),
}

impl<T: Clone> Clone for PatternElem<T> {
    fn clone(&self) -> Self {
        match self {
            PatternElem::Value(val) => PatternElem::Value(val.clone()),
            PatternElem::Matcher(_) => panic!("Cannot clone matcher function. Use Arc if you need to clone matchers."),
        }
    }
}

impl<T> PatternElem<T> {
    pub fn matches(&self, item: &T) -> bool {
        match self {
            PatternElem::Value(_) => panic!("Direct value matching requires T: PartialEq. Use matches_value instead."),
            PatternElem::Matcher(f) => f(item),
        }
    }

    pub fn matches_value(val: &T, item: &T) -> bool
    where
        T: PartialEq,
    {
        val == item
    }
}

/// A generic pattern matcher that scrolls through a queue of items of type `T`.
pub struct ScrollingWindowPatternMatcherRef<'a, T> {
    window: VecDeque<(u64, &'a T)>,
    max_pattern_len: usize,
    next_index: u64,
}

impl<'a, T: PartialEq> ScrollingWindowPatternMatcherRef<'a, T> {
    /// Create a new matcher with a maximum pattern length (window size).
    pub fn new(max_pattern_len: usize) -> Self {
        Self {
            window: VecDeque::with_capacity(max_pattern_len),
            max_pattern_len,
            next_index: 0,
        }
    }

    /// Push a new item into the window, maintaining the max size.
    pub fn push(&mut self, item: &'a T) {
        if self.window.len() == self.max_pattern_len {
            self.window.pop_front();
        }
        self.window.push_back((self.next_index, item));
    }
        self.next_index += 1;
    pub fn find_matches<'b, F>(
        &self,
        window: &'b [&'a T],
        patterns: &[PatternElem<T>],
        deduplicate: bool,
        mut on_match: Option<F>,
    ) -> Vec<(PatternId, usize)>
    where
        F: FnMut(PatternId, usize),
    {
        let mut matches = Vec::new();
        let mut seen = std::collections::HashSet::new();
        for (pat_id, pattern) in patterns.iter().enumerate() {
            let pat_len = 1; // Each PatternElem is a single element
            if pat_len == 0 || pat_len > window.len() {
                continue;
            }
            for i in 0..=window.len() - pat_len {
                let item = window[i];
                let is_match = match pattern {
                    PatternElem::Value(val) => val == item,
                    PatternElem::Matcher(f) => f(item),
                };
                if is_match {
                    if !deduplicate || seen.insert((pat_id, i)) {
                        if let Some(ref mut cb) = on_match {
                            cb(pat_id, i);
                        }
                        matches.push((pat_id, i));
                    }
                }
            }
        }
        matches
    }
    pub fn find_matches_with_callbacks(
        &self,
        window: &[&'a T],
        patterns: &[PatternWithCallback<'a, T>],
    ) {
        let mut matched_regions: Vec<(usize, usize, bool, usize)> = Vec::new(); // (start, len, allow_others_to_overlap, pat_id)
        for (pat_id, pat) in patterns.iter().enumerate() {
            let pat_len = pat.pattern.len();
            if pat_len == 0 || pat_len > window.len() {
                continue;
            }
            'outer: for i in 0..=window.len() - pat_len {
                // Check overlap with previous matches (across all patterns)
                for &(m_start, m_len, m_allow_others, _m_pat_id) in &matched_regions {
                    if regions_overlap(i, pat_len, m_start, m_len) {
                        // If either this pattern or the previous matched pattern disallows overlap, skip
                        if !pat.allow_overlap_with_others || !m_allow_others {
                            continue 'outer;
                        }
                    }
                }
                // Check pattern match
                let window_slice = &window[i..i + pat_len];
                let is_match = pat.pattern.iter().zip(window_slice).all(|(pelem, item)| match pelem {
                    PatternElem::Value(val) => val == *item,
                    PatternElem::Matcher(f) => f(item),
                });
                if is_match {
                    (pat.callback)(window_slice);
                    matched_regions.push((i, pat_len, pat.allow_others_to_overlap, pat_id));
                }
            }
        }
    }

impl<'a, T> ScrollingWindowFunctionPatternMatcherRef<'a, T> {
    /// Create a new matcher for function-only patterns (no PartialEq bound required).
    pub fn new(max_pattern_len: usize) -> Self {
        Self {
            window: VecDeque::with_capacity(max_pattern_len),
            max_pattern_len,
            next_index: 0,
        }
    }

    /// Push a new item into the window, maintaining the max size.
    pub fn push(&mut self, item: &'a T) {
        if self.window.len() == self.max_pattern_len {
            self.window.pop_front();
        }
        self.window.push_back((self.next_index, item));
    }

    /// Find matches using only function patterns (no PartialEq bound required)
    pub fn find_matches<'b, F>(
        &self,
        window: &'b [&'a T],
        patterns: &[Box<dyn Fn(&T) -> bool>],
        deduplicate: bool,
        mut on_match: Option<F>,
    ) -> Vec<(usize, usize)>
    where
        F: FnMut(usize, usize),
    {
        let mut matches = Vec::new();
        let mut seen = std::collections::HashSet::new();
        for (pat_id, pattern) in patterns.iter().enumerate() {
            let pat_len = 1;
            if pat_len == 0 || pat_len > window.len() {
                continue;
            }
            for i in 0..=window.len() - pat_len {
                let item = window[i];
                if pattern(item) {
                    if !deduplicate || seen.insert((pat_id, i)) {
                        if let Some(ref mut cb) = on_match {
                            cb(pat_id, i);
                        }
                        matches.push((pat_id, i));
                    }
                }
            }
        }
        matches
    }

    /// Find matches using patterns with callbacks and overlap settings (function-only)
    pub fn find_matches_with_callbacks(
        &self,
        window: &[&'a T],
        patterns: &[PatternWithCallbackFn<'a, T>],
    ) {
        let mut matched_regions: Vec<(usize, usize, bool)> = Vec::new(); // (start, len, allow_others_to_overlap)
        for (_pat_id, pat) in patterns.iter().enumerate() {
            let pat_len = pat.pattern.len();
            if pat_len == 0 || pat_len > window.len() {
                continue;
            }
            for i in 0..=window.len() - pat_len {
                // Check overlap with previous matches
                let mut overlaps = false;
                for &(m_start, m_len, m_allow_others) in &matched_regions {
                    if regions_overlap(i, pat_len, m_start, m_len) {
                        if !pat.allow_overlap_with_others || !m_allow_others {
                            overlaps = true;
                            break;
                        }
                    }
                }
                if overlaps {
                    continue;
                }
                // Check pattern match
                let window_slice = &window[i..i + pat_len];
                let is_match = pat.pattern.iter().zip(window_slice).all(|(f, item)| f(item));
                if is_match {
                    (pat.callback)(window_slice);
                    matched_regions.push((i, pat_len, pat.allow_others_to_overlap));
                    if !pat.allow_others_to_overlap {
                        // Optionally, skip ahead or break for performance
                    }
                }
            }
        }
    }
}

pub struct ScrollingWindowPatternMatcherOwned<T> {
    window: VecDeque<(u64, T)>,
    max_pattern_len: usize,
    next_index: u64,
}

impl<T: Clone> ScrollingWindowPatternMatcherOwned<T> {
    /// Create a new matcher with a maximum pattern length (window size).
    pub fn new(max_pattern_len: usize) -> Self {
        Self {
            window: VecDeque::with_capacity(max_pattern_len),
            max_pattern_len,
            next_index: 0,
        }
    }

    /// Push a new item into the window, maintaining the max size.
    pub fn push(&mut self, item: T) {
        if self.window.len() == self.max_pattern_len {
            self.window.pop_front();
        }
        self.window.push_back((self.next_index, item));
        self.next_index += 1;
    }

    /// Find matches for the given patterns, returning a map of index to pattern IDs and owned items.
    pub fn find_matches(&self, patterns: &[Vec<PatternElem<T>>]) -> HashMap<u64, (Vec<PatternId>, T)>
    where
        T: PartialEq,
    {
        let mut matches: HashMap<u64, (Vec<PatternId>, T)> = HashMap::new();
        let min_pat_len = patterns.iter().map(|p| p.len()).min().unwrap_or(0);
        if self.window.len() < min_pat_len {
            return matches;
        }
        for (pat_id, pattern) in patterns.iter().enumerate() {
            let pat_len = pattern.len();
            if pat_len == 0 || pat_len > self.window.len() {
                continue;
            }
            for i in 0..=self.window.len() - pat_len {
                let window_slice = &self.window.as_slices().0[i..i+pat_len];
                if window_slice.iter().zip(pattern.iter()).all(|((_, item), pelem)| pelem.matches(item)) {
                    let idx = window_slice[0].0;
                    let t = window_slice[0].1.clone();
                    matches.entry(idx).or_insert_with(|| (vec![], t)).0.push(pat_id);
                }
            }
        }
        matches
    }
}

pub type PatternId = usize;

/// Pattern with callback and overlap settings for value/mixed patterns
pub struct PatternWithCallback<'a, T> {
    pub pattern: Vec<PatternElem<T>>,
    pub callback: Box<dyn Fn(&[&'a T]) + 'a>,
    pub allow_overlap_with_others: bool,
    pub allow_others_to_overlap: bool,
}

/// Pattern with callback and overlap settings for function-only patterns
pub struct PatternWithCallbackFn<'a, T> {
    pub pattern: Vec<Box<dyn Fn(&T) -> bool>>,
    pub callback: Box<dyn Fn(&[&'a T]) + 'a>,
    pub allow_overlap_with_others: bool,
    pub allow_others_to_overlap: bool,
}

fn regions_overlap(a_start: usize, a_len: usize, b_start: usize, b_len: usize) -> bool {
    let a_end = a_start + a_len;
    let b_end = b_start + b_len;
    a_start < b_end && b_start < a_end
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::collections::VecDeque;
    use std::rc::Rc;
    use std::cell::RefCell;

    #[test]
    fn test_value_and_function_patterns() {
        let window = vec![&1, &2, &3, &4];
        let patterns = vec![
            PatternElem::Value(1),
            PatternElem::Matcher(Box::new(|x: &i32| *x == 2)),
        ];
        let matcher = ScrollingWindowPatternMatcherRef::new(4);
        let matches = matcher.find_matches(&window, &patterns, false, None::<fn(usize, usize)>);
        assert!(matches.contains(&(0, 0)));
        assert!(matches.contains(&(1, 1)));
    }

    #[test]
    fn test_function_only_patterns() {
        let window = vec![&1, &2, &3, &4];
        let patterns_fn: Vec<Box<dyn Fn(&i32) -> bool>> = vec![
            Box::new(|x| *x == 1),
            Box::new(|x| *x == 4),
        ];
        let matcher = ScrollingWindowFunctionPatternMatcherRef::new(4);
        let matches = matcher.find_matches(&window, &patterns_fn[..], false, None::<fn(usize, usize)>);
        assert!(matches.contains(&(0, 0)));
        assert!(matches.contains(&(1, 3)));
    }

    #[test]
    fn test_mixed_patterns_and_deduplication() {
        let matcher = ScrollingWindowPatternMatcherRef {
            window: VecDeque::new(),
            max_pattern_len: 0,
            next_index: 0,
        };
        let window = vec![&1, &2, &1, &2, &1];
        let patterns = vec![
            PatternElem::Value(1),
            PatternElem::Matcher(Box::new(|x: &i32| *x == 2)),
        ];
        // No deduplication
        let matches = matcher.find_matches(&window, &patterns, false, None::<fn(usize, usize)>);
        assert_eq!(matches.iter().filter(|(pid, _)| *pid == 0).count(), 3);
        assert_eq!(matches.iter().filter(|(pid, _)| *pid == 1).count(), 2);
        // With deduplication
        let matches = matcher.find_matches(&window, &patterns, true, None::<fn(usize, usize)>);
        assert_eq!(matches.iter().filter(|(pid, _)| *pid == 0).count(), 3);
        assert_eq!(matches.iter().filter(|(pid, _)| *pid == 1).count(), 2);
    }

    #[test]
    fn test_overlapping_matches() {
        let matcher = ScrollingWindowPatternMatcherRef {
            window: VecDeque::new(),
            max_pattern_len: 0,
            next_index: 0,
        };
        let window = vec![&1, &1, &1];
        let patterns = vec![PatternElem::Value(1)];
        let matches = matcher.find_matches(&window, &patterns, false, None::<fn(usize, usize)>);
        assert_eq!(matches, vec![(0, 0), (0, 1), (0, 2)]);
    }

    #[test]
    fn test_function_only_edge_cases() {
        let matcher = ScrollingWindowFunctionPatternMatcherRef {
            window: VecDeque::new(),
            max_pattern_len: 0,
            next_index: 0,
        };
        let window: Vec<&i32> = vec![];
        let patterns_fn: Vec<Box<dyn Fn(&i32) -> bool>> = vec![Box::new(|_| true)];
        let matches = matcher.find_matches(&window, &patterns_fn[..], false, None::<fn(usize, usize)>);
        assert!(matches.is_empty());
    }

    #[test]
    fn test_callback_invocation() {
        let window = vec![&1, &2, &3];
        let patterns = vec![PatternElem::Value(2)];
        let matcher = ScrollingWindowPatternMatcherRef::new(3);
        let mut called = false;
        let _ = matcher.find_matches(&window, &patterns, false, Some(|pid, idx| {
            assert_eq!(pid, 0);
            assert_eq!(idx, 1);
            called = true;
        }));
        assert!(called);
    }

    #[test]
    fn test_value_patterns_with_callbacks_and_overlap() {
        let window = vec![&1, &2, &1, &2, &1];
        let results: Rc<RefCell<Vec<Vec<i32>>>> = Rc::new(RefCell::new(vec![]));
        let results1 = results.clone();
        let results2 = results.clone();
        let patterns = vec![
            PatternWithCallback {
                pattern: vec![PatternElem::Value(1), PatternElem::Value(2)],
                callback: Box::new(move |matched| results1.borrow_mut().push(matched.iter().map(|x| **x).collect::<Vec<_>>())),
                allow_overlap_with_others: false,
                allow_others_to_overlap: true,
            },
            PatternWithCallback {
                pattern: vec![PatternElem::Value(2), PatternElem::Value(1)],
                callback: Box::new(move |matched| results2.borrow_mut().push(matched.iter().map(|x| **x).collect::<Vec<_>>())),
                allow_overlap_with_others: true,
                allow_others_to_overlap: false,
            },
        ];
        let matcher = ScrollingWindowPatternMatcherRef::new(5);
        matcher.find_matches_with_callbacks(&window, &patterns);
        let results = results.borrow();
        assert!(results.contains(&vec![1, 2]));
        assert!(results.contains(&vec![2, 1]));
    }

    #[test]
    fn test_function_patterns_with_callbacks_and_overlap() {
        let window = vec![&1, &2, &3, &4];
        let results: Rc<RefCell<Vec<Vec<i32>>>> = Rc::new(RefCell::new(vec![]));
        let results1 = results.clone();
        let results2 = results.clone();
        let patterns = vec![
            PatternWithCallbackFn {
                pattern: vec![
                    Box::new(|x: &i32| *x == 1) as Box<dyn Fn(&i32) -> bool>,
                    Box::new(|x: &i32| *x == 2) as Box<dyn Fn(&i32) -> bool>,
                ],
                callback: Box::new(move |matched| results1.borrow_mut().push(matched.iter().map(|x| **x).collect::<Vec<_>>())),
                allow_overlap_with_others: false,
                allow_others_to_overlap: true,
            },
            PatternWithCallbackFn {
                pattern: vec![
                    Box::new(|x: &i32| *x == 2) as Box<dyn Fn(&i32) -> bool>,
                    Box::new(|x: &i32| *x == 3) as Box<dyn Fn(&i32) -> bool>,
                ],
                callback: Box::new(move |matched| results2.borrow_mut().push(matched.iter().map(|x| **x).collect::<Vec<_>>())),
                allow_overlap_with_others: true,
                allow_others_to_overlap: false,
            },
        ];
        let matcher = ScrollingWindowFunctionPatternMatcherRef::new(4);
        matcher.find_matches_with_callbacks(&window, &patterns);
        let results = results.borrow();
        assert!(results.contains(&vec![1, 2]));
        assert!(results.contains(&vec![2, 3]));
    }

    #[test]
    fn test_overlap_exclusion_behavior() {
        let window = vec![&1, &2, &1, &2, &1];
        let results: Rc<RefCell<Vec<Vec<i32>>>> = Rc::new(RefCell::new(vec![]));
        let results1 = results.clone();
        let results2 = results.clone();
        let patterns = vec![
            PatternWithCallback {
                pattern: vec![PatternElem::Value(1), PatternElem::Value(2)],
                callback: Box::new(move |matched| results1.borrow_mut().push(matched.iter().map(|x| **x).collect::<Vec<_>>())),
                allow_overlap_with_others: false,
                allow_others_to_overlap: false,
            },
            PatternWithCallback {
                pattern: vec![PatternElem::Value(2), PatternElem::Value(1)],
                callback: Box::new(move |matched| results2.borrow_mut().push(matched.iter().map(|x| **x).collect::<Vec<_>>())),
                allow_overlap_with_others: false,
                allow_others_to_overlap: false,
            },
        ];
        let matcher = ScrollingWindowPatternMatcherRef::new(5);
        matcher.find_matches_with_callbacks(&window, &patterns);
        let results = results.borrow();
        // Only the first non-overlapping match should be present
        assert!(results.contains(&vec![1, 2]) || results.contains(&vec![2, 1]));
        assert_eq!(results.len(), 1);
    }

    #[test]
    fn test_empty_window_and_pattern() {
        let window: Vec<&i32> = vec![];
        let results: Rc<RefCell<Vec<Vec<i32>>>> = Rc::new(RefCell::new(vec![]));
        let patterns: Vec<PatternWithCallback<i32>> = vec![];
        let matcher = ScrollingWindowPatternMatcherRef::new(0);
        matcher.find_matches_with_callbacks(&window, &patterns);
        let results = results.borrow();
        assert!(results.is_empty());
    }
}
