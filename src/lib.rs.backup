// Type aliases for complex callback types
pub type Callback<T> = Box<dyn Fn(&T) -> bool + 'static>;
pub type SliceCallback<T> = Box<dyn Fn(&[T]) + 'static>;

// Struct for patterns with callbacks and overlap settings
pub struct PatternWithCallback<T> {
    pub pattern: Vec<T>,
    pub callback: SliceCallback<T>,
    pub allow_overlap_with_others: bool,
    pub allow_others_to_overlap: bool,
}

// Core types
pub enum PatternElem<T> {
    Value(T),
    Matcher(Callback<T>),
}

pub struct Pattern<T> {
    pub pattern: Vec<PatternElem<T>>,
    pub callback: Option<Box<dyn Fn(&[T]) + 'static>>,
    pub deduplication: bool,
    pub overlap: bool,
}

/// Builder for PatternElem
pub struct PatternElemBuilder<T> {
    value: Option<T>,
    matcher: Option<Callback<T>>,
}

impl<T> Default for PatternElemBuilder<T> {
    fn default() -> Self {
        Self::new()
    }
}

impl<T> PatternElemBuilder<T> {
    /// Create a new builder
    pub fn new() -> Self {
        Self { value: None, matcher: None }
    }
    /// Set the value for the PatternElem
    pub fn value(mut self, val: T) -> Self {
        self.value = Some(val);
        self
    }
    /// Set the matcher (predicate) for the PatternElem
    pub fn matcher(mut self, f: Callback<T>) -> Self {
        self.matcher = Some(f);
        self
    }
    /// Optionally set the value
    pub fn value_opt(mut self, val: Option<T>) -> Self {
        if let Some(v) = val { self = self.value(v); }
        self
    }
    /// Optionally set the matcher
    pub fn matcher_opt(mut self, f: Option<Callback<T>>) -> Self {
        if let Some(m) = f { self = self.matcher(m); }
        self
    }
    /// Build the PatternElem
    pub fn build(self) -> PatternElem<T> {
        match (self.value, self.matcher) {
            (Some(val), None) => PatternElem::Value(val),
            (None, Some(f)) => PatternElem::Matcher(f),
            _ => panic!("PatternElemBuilder requires either value or matcher"),
        }
    }
}

impl<T> PatternElem<T> {
    /// Create a PatternElem from optional value and matcher
    pub fn from_all(value: Option<T>, matcher: Option<Callback<T>>) -> Self {
        PatternElemBuilder::new().value_opt(value).matcher_opt(matcher).build()
    }
}

/// Builder for Pattern
pub struct PatternBuilder<T> {
    pattern: Option<Vec<PatternElem<T>>>,
    callback: Option<Box<dyn Fn(&[T]) + 'static>>,
    deduplication: Option<bool>,
    overlap: Option<bool>,
}

impl<T> Default for PatternBuilder<T> {
    fn default() -> Self {
        Self::new()
    }
}

impl<T> PatternBuilder<T> {
    /// Create a new builder
    pub fn new() -> Self {
        Self { pattern: None, callback: None, deduplication: None, overlap: None }
    }
    /// Set the pattern sequence
    /// Set the pattern sequence (Vec of PatternElem)
    pub fn pattern(mut self, pat: Vec<PatternElem<T>>) -> Self {
        self.pattern = Some(pat);
        self
    }
    /// Set the callback for the pattern
    /// Set the callback for the pattern (receives the matched slice)
    pub fn callback<F: Fn(&[T]) + 'static>(mut self, cb: F) -> Self {
        self.callback = Some(Box::new(cb));
        self
    }
    /// Set deduplication
    pub fn deduplication(mut self, val: bool) -> Self {
        self.deduplication = Some(val);
        self
    }
    /// Set overlap
    pub fn overlap(mut self, val: bool) -> Self {
        self.overlap = Some(val);
        self
    }
    /// Optionally set the callback
    pub fn callback_opt(mut self, cb: Option<Box<dyn Fn(&[T]) + 'static>>) -> Self {
        if let Some(c) = cb { self.callback = Some(c); }
        self
    }
    /// Build the Pattern
    pub fn build(self) -> Pattern<T> {
        Pattern {
            pattern: self.pattern.unwrap_or_default(),
            callback: self.callback,
            deduplication: self.deduplication.unwrap_or(false),
            overlap: self.overlap.unwrap_or(false),
        }
    }
}

    /// Create a new Pattern from a sequence of PatternElem
    pub fn new(pattern: Vec<PatternElem<T>>) -> Self {
        Pattern {
            pattern,
            callback: None,
            deduplication: false,
            overlap: false,
        }
    }
    /// Create a Pattern with a callback (receives the matched slice)
    pub fn with_callback(pattern: Vec<PatternElem<T>>, callback: impl Fn(&[T]) + 'static) -> Self {
        Pattern {
            pattern,
            callback: Some(Box::new(callback)),
            deduplication: false,
            overlap: false,
        }
    }

    pub fn from_all(pattern: Vec<T>, callback: Option<Box<dyn Fn(&[T]) + 'static>>, deduplication: bool, overlap: bool) -> Self {
        PatternBuilder::new()
            .pattern(pattern)
            .callback_opt(callback)
            .deduplication(deduplication)
            .overlap(overlap)
            .build()
    }
    pub fn builder() -> PatternBuilder<T> {
        PatternBuilder::new()
    }
}

// Stubs for matcher types used in doc tests
pub struct ScrollingWindowPatternMatcherRef;

impl ScrollingWindowPatternMatcherRef {
    pub fn new(_window_size: usize) -> Self { Self }
    /// Finds matches for value/mixed patterns, optionally invoking per-pattern callbacks and handling overlap settings.
    ///
    /// If a pattern is a `PatternWithCallback`, its callback will be invoked for each match, and overlap settings will be respected.
    /// If a pattern is a plain Vec<PatternElem<T>>, matches are returned as (window index, pattern index).
    pub fn find_matches<T>(&self, window: &[T], patterns: &[Pattern<T>]) -> Vec<(usize, usize)>
    where T: PartialEq + Clone
    {
        let mut matches = Vec::new();
        let mut matched_ranges: Vec<(usize, usize)> = Vec::new();
        for (p_idx, pat) in patterns.iter().enumerate() {
            let pat_len = pat.pattern.len();
            if pat_len == 0 || window.len() < pat_len { continue; }
            let mut w_idx = 0;
            while w_idx <= window.len() - pat_len {
                let candidate = &window[w_idx..w_idx+pat_len];
                let mut matched = true;
                for (offset, elem) in pat.pattern.iter().enumerate() {
                    match elem {
                        PatternElem::Value(v) => {
                            if &candidate[offset] != v {
                                matched = false;
                                break;
                            }
                        }
                        PatternElem::Matcher(f) => {
                            if !f(&candidate[offset]) {
                                matched = false;
                                break;
                            }
                        }
                    }
                }
                if matched {
                    // Overlap checks if needed
                    let mut overlaps = false;
                    if !pat.overlap {
                        for &(start, end) in &matched_ranges {
                            let range_start = w_idx;
                            let range_end = w_idx + pat_len - 1;
                            if !(range_end < start || range_start > end) {
                                overlaps = true;
                                break;
                            }
                        }
                    }
                    if pat.overlap || !overlaps {
                        // Invoke callback if present
                        if let Some(ref cb) = pat.callback {
                            cb(candidate);
                        }
                        matches.push((w_idx, p_idx));
                        if !pat.deduplication {
                            matched_ranges.push((w_idx, w_idx + pat_len - 1));
                        }
                    }
                }
                w_idx += 1;
            }
        }
        matches
    }
}
